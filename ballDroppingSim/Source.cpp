/*
* By: Gordon Yeh
* Starting date: 3/25/2016
*/

/*
* a ball will be generated by click the right mouse button
* the ball will fall from the top of the window to the bottom, and it also might bounce if it hits something!
* multiples can exist at once, which generates some funky interaction
*/

#include <SFML/Graphics.hpp>
#include <iostream>
#include <ctime>
#include <math.h>
#include <windows.h>
#include "vectorCalc.h"
#include "ball.h"
#define g 9.81
#define m2p 50.0


using namespace std;
int numOfBalls = 0;


bool checkCollision(ball *b1, ball *b2, float R[]);

int main()
{
	srand(time(0));
	sf::Vector2f mouseP;
	const int numLimit = 20;

	//array to store objects
	sf::CircleShape* shape[numLimit];
	ball* ballo[numLimit];

	int i;
	int j;
	int t = 0;
	const int dimension = 2;
	// r - coordinates of object
	// v - velocity
	float r1[dimension], r2[dimension], R12[dimension];
	float v1[dimension], v2[dimension];

	//timer between all the balls for the collision, size of matrix:num of balls x num of balls
	//ie, collideMeter[0][4] - timer for the  collision between ball 0 and ball 4
	clock_t collideMeter[numLimit][numLimit];

	sf::RenderWindow window(sf::VideoMode(1000, 1000), "Ball Dropping Simulation!");

	while (window.isOpen())
	{
		sf::Event event;

		while (window.pollEvent(event)){

			switch (event.type){

			case sf::Event::Closed:
				window.close();
				break;

			case sf::Event::MouseButtonPressed:
				//sense where mouse was clicked on the window
				mouseP = static_cast<sf::Vector2f>(sf::Mouse::getPosition(window));
				if (numOfBalls < 20){
					//print location of the cursor 
					cout << "mouse is clicked" << endl;
					cout << mouseP.x << endl;
					cout << mouseP.y << endl;
					//generate a ball
					ballo[numOfBalls] = new ball;
					//generate a shape
					shape[numOfBalls] = ballo[numOfBalls];
					//initalize the ball
					ballo[numOfBalls]->initialize(shape[numOfBalls], &mouseP);
					//start collision timer
					for (j = 0; j < numLimit; j++){
						collideMeter[numOfBalls][j] = clock();
					}
					cout << ballo[numOfBalls]->getMass() << endl;
					numOfBalls++;
				}
				if (event.mouseButton.button == sf::Mouse::Right){
					system("pause");
				}
				break;
			}
		}

			//set the balls to the next position
			for (i = 0; i < numOfBalls; i++) ballo[i]->moveNext(shape[i]);

			//get the next position
			for (i = 0; i < (numOfBalls-1); i++){
				ballo[i]->getPosition(r1);

				//check for collision
				for (j = (i + 1); j < numOfBalls; j++){
					ballo[j]->getPosition(r2);
					R12[0] = r1[0] - r2[0];
					R12[1] = r1[1] - r2[1];

					//TRUE - the balls collided && a collision between the 2 has not occurred recently
					if (checkCollision(ballo[i], ballo[j], R12) && (clock() - collideMeter[i][j]) > 300){
						convert2Uni(R12, dimension);
						ballo[i]->getVelo(v1);
						ballo[j]->getVelo(v2);
						
						//calculated the velocities after collision
						collisionCalc2D(v1, v2, R12, ballo[i]->getMass(), ballo[j]->getMass(), (float)0.7);
						ballo[i]->switchVelo(v1, r1);
						ballo[j]->switchVelo(v2, r2);

						//reset the timer
						collideMeter[i][j] = clock();
					}
				}
			}
			window.clear();
			for (i = 0; i < numOfBalls; i++) window.draw(*shape[i]);
			window.display();
	}
	return 0;
}

//bo1, bo2 - ball objects
//R - displacement between bo1 and bo2
//TRUE - magitude of the displacement between 2 balls equals the sum of the radius
//		 this means the 2 balls have collided
bool checkCollision(ball *bo1, ball *bo2, float R[]){
	if ( norm(R, 2) <= (bo1->getRadius() + bo2->getRadius())){
		return TRUE;
	}
	return FALSE;
}